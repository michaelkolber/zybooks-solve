"""Solves all of a user's zyBooks. By default, this only completes "participation" activities, 
but this can be easily changed by changing the constant below.

You can call the session directly with a username, password and user agent string, or pass 
in the path to a JSON object containing "username", "password", and "user-agent" keys.


Note that this program has only been tested with "participation" activities.
"""

import datetime
import hashlib
import json
import random
import sys
import time
from typing import List, Optional
import urllib.parse

from bs4 import BeautifulSoup as bs
import requests

import errors


# CONSTANTS
ONLY_SOLVE_PARTICIPATION = True  # Only solve "participation" activities
WAIT_BETWEEN_SOLVES = True       # Wait a random number of seconds between solving each activity


# HELPER FUNCTIONS
def check_json_response(res, error_message):
	"""Helper method that exits the program if a request failed."""
	if not res.json()['success']:
		raise errors.SolverError(f'\n[ERROR] {error_message}\n')


def wait_random_secs(min, max, indent_level=0):
	if not WAIT_BETWEEN_SOLVES:
		return
	secs = random.randint(min, max)
	print('\t'*indent_level + f'[SLEEP] {secs} seconds...')
	time.sleep(secs)


def check_if_complete(component, subcomponents) -> None:
	"""Check if a component (book, chapter, section, etc.) is complete by checking if its 
	subcomponents are complete. Assign the result to the component's `complete` property."""
	for subcomponent in subcomponents:
		if not subcomponent.complete:
			if ONLY_SOLVE_PARTICIPATION and isinstance(subcomponent, zyBookActivity) and subcomponent.activity_type != 'participation':  # Treat participation activities as completed for sleeping purposes
				continue
			component.complete = False
			return
	component.complete = True


def _calculate_internal_checksum(book: 'zyBook') -> str:
	"""This function is kept because it may be useful one day. It has no purpose at this moment.
	
	This calculation is done on the zyBooks front-end, but doesn't actually end up getting 
	sent to the server.
	
	The checksum is generated by taking the activity ID of each activity followed by a 
	boolean completion value for each sub-activity of that activity. All of these are 
	concatenated. This is then computed as an md5 hash.
	"""
	activity_completions = []
	for chapter in book.chapters:
		for section in chapter.sections:
			for activity in section.activities:
				activity_completions.append(str(activity.id))
				for subactivity in activity.subactivities:
					activity_completions.append(str(int(subactivity.complete)))
	md5 = hashlib.md5(''.join(activity_completions).encode('utf_8'))
	
	return md5


# CLASSES
class zyBooksSession:
	"""A session on the zyBooks website.
	
	It can take a username, password, and user agent string, or a path to a credentials 
	file. The credentials file should be a JSON object with "username" and "password" fields 
	and optionally a "user-agent" field.
	"""
	def __init__(self, username:str=None, password:str=None, user_agent:str=None, credentials_path:str=None) -> None:
		self.auth_token: str
		self.books: List[zyBook] = []
		self.buildkey: str  # Some sort of key included in the HTML, required to create the checksums
		self.credentials = {
			'username': username,
			'password': password
		}
		self.session: requests.Session
		self.user_agent: str = user_agent
		self.user_id: int
		
		# Check if we should be reading credentials from a credentials file.
		if credentials_path:
			with open(credentials_path, mode='r') as credentials_file:
				creds = json.load(credentials_file)
				if 'username' in creds and 'password' in creds:
					self.credentials = {
						'username': creds['username'],
						'password': creds['password']
					}
				else:
					raise ValueError("The supplied credentials file does not have 'username' and 'password' fields.")
				
				# Set the user agent if appropriate
				if 'user-agent' in creds:
					self.user_agent = creds['user-agent']
		
		self._generate_session()
		self._get_buildkey()
		self._get_zybooks()
	
	
	def _generate_session(self) -> None:
		"""Generate a new Requests `Session`, log in, and store the session with the 
		`zyBooksSession` instance."""
		print('Generating session...')
		
		self.session = requests.Session()  # We'll use Requests' `Session` class for this
		self.session.headers = {
			'user-agent': self.user_agent,
			'Accept-Language': 'en-US,en;q=0.9',
			'Dnt': '1',
			'Upgrade-Insecure-Requests': '1',
			'Origin': 'https://learn.zybooks.com'
		}
		
		self._login()
	
	
	def _login(self) -> None:
		"""Log in to zyBooks with the credentials we got when creating the `zyBooksSession` 
		instance."""
		print(f'\tLogging in {self.credentials["username"]}...')
		
		url = 'https://zyserver.zybooks.com/v1/signin'

		data = {
			'email': self.credentials['username'],
			'password': self.credentials['password'],
		}
		
		headers = {
			'Referer': 'https://learn.zybooks.com/signin'
		}

		res = self.session.post(url=url, json=data)
		check_json_response(res, 'Could not log in.')

		self.auth_token = res.json()['session']['auth_token']
		self.user_id = res.json()['user']['user_id']
		
		print('\tSuccessfully logged in!\n')
	
	
	def _get_buildkey(self) -> None:
		"""Gets the "buildkey", a hexadecimal key included in the Ember app HTML (required 
		to calculate the checksum)."""
		
		res = self.session.get('https://learn.zybooks.com/library')
		
		soup = bs(res.text, features='lxml')
		app_json = soup.find('meta', attrs={'name': 'zybooks-web/config/environment'})
		
		if not app_json:
			raise errors.NoBuildkeyError('Could not find the appropriate meta tag on the page.')
		
		self.buildkey = json.loads(urllib.parse.unquote(app_json['content']))['APP']['BUILDKEY']
	
	
	def _get_zybooks(self) -> None:
		"""Get a list of the user's zyBooks, excluding the default ones supplied by the 
		website."""
		print('Getting zyBooks...')
		
		url = f'https://zyserver.zybooks.com/v1/user/{self.user_id}/items'
		
		params = {
			'items': '["zybooks"]',
			'auth_token': self.auth_token,
		}
		
		headers = {
			'Referer': 'https://learn.zybooks.com/signin'
		}
		
		res = self.session.get(url, params=params)
		check_json_response(res, 'Could not get list of zyBooks.')
		
		for book in res.json()['items']['zybooks']:  # For each book found
			if book['institution_id']:  # If it's not a default book
				print(f"Found book with code '{book['zybook_code']}'", end='')
				self._create_book(book['zybook_code'])
				
	
	def _create_book(self, code: str) -> None:
		"""Helper function to create a `zyBook` instance."""
		self.books.append(zyBook(self, code))
	
	
	def regenerate_session(self) -> None:
		"""Create a new session with the credentials already stored in the `zyBooksSession` 
		instance."""
		self._generate_session()
	
	
	def solve_all(self):
		print(f'Solving all books for user {self.credentials["username"]}:')
		for i, book in enumerate(self.books):
			book.solve()
			# If we only have one book, we don't have to wait between books. Also don't wait on the last book.
			if len(self.books) > 1 and i != len(self.books) - 1:
				wait_random_secs(60, 94, 1)
			


class zyBook:
	def __init__(self, session: zyBooksSession, code: str) -> None:
		self.code: str = code  # Internal code for the zyBook (shows up in the book URL)
		self.chapters: List[zyBookChapter] = []
		self.zb_session: zyBooksSession = session  # The session we'll be using for all operations
		self.title: str  # Human-readable name for the zyBook
		
		self._get_book_info()
		self._collect_problems()
	
	def _get_book_info(self) -> None:
		url = 'https://zyserver.zybooks.com/v1/zybooks'
		
		params = {
			'zybooks': f'["{self.code}"]',
			'auth_token': self.zb_session.auth_token,
		}
		
		headers = {
			'Referer': 'https://learn.zybooks.com/library'
		}
		
		res = self.zb_session.session.get(url=url, params=params)
		check_json_response(res, f"Could not get book info for book code {self.code}.")
		
		self.title = res.json()['zybooks'][0]['title']
		
		print(f' ({self.title}):')
		print('\tRetrieved book info')
		
		for chapter in res.json()['zybooks'][0]['chapters']:
			self.chapters.append(zyBookChapter(self, chapter))
		
		print()
	
	
	def _collect_problems(self) -> None:
		print('\tCollecting book problems...')
		
		url = f'https://zyserver.zybooks.com/v1/zybook/{self.code}/activities/{self.zb_session.user_id}'
		
		params = {
			'auth_token': self.zb_session.auth_token
		}
		
		headers = {
			'Referer': f'https://learn.zybooks.com/zybook/{self.code}'
		}
		
		res = self.zb_session.session.get(url=url, params=params)
		check_json_response(res, f'Could not collect book problems for {self.title}')
		
		metadata = res.json()['content_resource_metadata']
		completion_data = res.json()['data']
		
		if len(self.chapters) != len(metadata) != len(completion_data):
			raise ValueError(f"[ERROR] The sizes of the chapters, data, and metadata don't match.\nChapters: {len(self.chapters)} | Data: {len(completion_data)} | Metadata: {len(metadata)}")
		
		for chapter, chapter_md, chapter_cd in zip(self.chapters, metadata, completion_data):  # For each chapter
			# print(f'\tCollecting problems from Chapter {chapter.number}: {chapter.title}:')
			for section, section_md, section_cd in zip(chapter.sections, chapter_md, chapter_cd):  # For each section
				# print(f'\t\tCollecting problems from Section {section.number}: {section.title}...')
				for i, activity_md in enumerate(section_md):
					activity_caption = activity_md['caption']
					activity_id = activity_md['content_resource_id']
					activity_tool = activity_md['tool'] if 'tool' in activity_md else None
					activity_tool_type = activity_md['type']
					activity_type = activity_md['activity_type']
					activity_completion_data = section_cd[str(activity_id)]
					
					section.activities.append(zyBookActivity(section, activity_type, activity_caption, activity_completion_data, activity_id, i + 1, activity_tool, activity_tool_type))
				check_if_complete(section, section.activities)
			check_if_complete(chapter, chapter.sections)
		check_if_complete(self, self.chapters)
		print('\tDone collecting problems.\n')
	
	
	def _generate_checksum(self, activity_id:str, timestamp:str) -> str:
		"""Generate the checksum that the zyBooks server requires to process a request.
		
		The checksum is a combination of a few strings:
		
		1. The API URL
		2. The timestamp
		3. The auth token
		4. The "buildkey" (see `zyBooksSession._get_buildkey()`)
		"""
		
		md5 = hashlib.md5()
		
		md5.update(f'content_resource/{activity_id}/activity'.encode('utf_8'))
		md5.update(timestamp.encode('utf_8'))
		md5.update(self.zb_session.auth_token.encode('utf_8'))
		md5.update(self.zb_session.buildkey.encode('utf_8'))
		
		return md5.hexdigest()
	
	
	def solve(self) -> None:
		"""Solve the book. If all of its chapters were already solved, return `False`. 
		Otherwise, return `True`."""
		if self.complete:
			print(f"\t[INFO] Book '{self.title}' already solved, skipping...")
			return False
		
		print('\tSolving book...')
		for i, chapter in enumerate(self.chapters):
			if chapter.solve() and i != len(self.chapters) - 1:   # Only wait if it solved something and it's not the last iteration
				wait_random_secs(14, 22, 2)
		return True				



class zyBookChapter:
	def __init__(self, book: zyBook, chapter_json: dict) -> None:
		self.number: int  # Number within the book
		self.sections: List[zyBookSection] = []
		self.title: str
		self.zyBook: zyBook = book  # The book that this chapter belongs to
		
		self._parse_json(chapter_json)
	
	
	def _parse_json(self, chapter_json: dict) -> None:
		self.number = chapter_json['number']
		self.title = chapter_json['title']
		
		# print(f'\tRetrieved Chapter {self.number}: {self.title}')
		
		for section_json in chapter_json['sections']:
			self.sections.append(zyBookSection(self, section_json))
	
	
	def solve(self) -> None:
		"""Solve the chapter. If all of its sections were already solved, return `False`. 
		Otherwise, return `True`."""
		if self.complete:
			print(f'\t[INFO] Chapter {self.number} already solved, skipping...')
			return False
			
		print(f'\tSolving Chapter {self.number}:')
		for i, section in enumerate(self.sections):
			if section.solve() and i != len(self.sections) - 1:  # Only wait if it solved something and it's not the last iteration
				wait_random_secs(5, 9, 2)
		return True



class zyBookSection:
	def __init__(self, chapter: zyBookChapter, section_json: dict) -> None:
		self.activities: List[zyBookActivity] = []
		self.chapter: zyBookChapter = chapter  # The chapter that this section belongs to
		self.complete: bool  # Whether or not the chapter has been completed (by the user or by this program)
		self.id: int  # Probably unique across all of zyBooks
		self.number: int  # Number within the chapter
		self.optional: bool
		self.title: str
		
		self._parse_json(section_json)
	
	
	def _parse_json(self, section_json: dict):
		self.id = section_json['canonical_section_id']
		self.number = section_json['canonical_section_number']
		self.optional = section_json['optional']
		self.title = section_json['title']
		
		# print(f'\t\tRetrieved Section {self.number}: {self.title}')
	
	
	def solve(self) -> bool:
		"""Solve the section. If all of its activities were already solved, return `False`. 
		Otherwise, return `True`."""
		if self.complete:
			print(f'\t\t[INFO] Section {self.number} already solved, skipping...')
			return False
			
		print(f'\t\tSolving Section {self.number}:')
		for i, activity in enumerate(self.activities):
			if activity.solve() and i != len(self.activities) - 1:  # Only wait if it solved something and it's not the last iteration
				wait_random_secs(3, 7, 3)
		return True



class zyBookActivity:
	def __init__(self, section:zyBookSection, activity_type:str, caption:str, completion_data:List[int], activity_id:int, number:int, tool:Optional[str], activity_tool_type:str) -> None:
		self.activity_type: str = activity_type  # One of "participation", "challenge", or "lab"
		self.caption: str = caption  # The caption under the activity
		self.complete: bool  # Whether or not the activity has been completed
		self.id: int = activity_id  # Probably unqiue across all of zyBooks
		self.number: int = number  # The activity number within the section
		self.section: zyBookSection = section  # The section that this activity belongs to
		self.subactivities: List[zyBookSubActivity] = []  # The sub-activities for this section
		self.tool: Optional[str] = tool  # The tool used for the question. Appears to only be a thing for `custom`-type questions
		self.tool_type: str = activity_type  # E.g. multiple choice, custom, etc.
		
		self._create_subactivities(completion_data)
	
	def _create_subactivities(self, completion_data: list):
		for i, complete in enumerate(completion_data):
			self.subactivities.append(zyBookSubActivity(self, i, bool(complete)))
		
		# Calculate activity completion status
		check_if_complete(self, self.subactivities)
	
	def solve(self) -> bool:
		"""Solve the activity. If all of its sub-activities were already solved, return 
		`False`. Otherwise, return `True`."""
		
		# We only care about "participation" activities for this class
		if ONLY_SOLVE_PARTICIPATION and self.activity_type != 'participation':
			print(f"\t\t\t[INFO] Activity {self.number} is a '{self.activity_type}' activity, skipping...")
			return False
		
		if self.complete:
			print(f'\t\t\t[INFO] Activity {self.number} already solved, skipping...')
			return False
			
		print(f'\t\t\tSolving Activity {self.number}:')
		for i, subactivity in enumerate(self.subactivities):
			if subactivity.solve() and i != len(self.subactivities) - 1:  # Only wait if it solved something and it's not the last iteration
				wait_random_secs(3, 5, 4)
		return True
		


class zyBookSubActivity:
	def __init__(self, activity:zyBookActivity, number:int, complete:bool) -> None:
		self.activity: zyBookActivity = activity  # The main activity to which this sub-activity belongs
		self.complete: bool = complete  # Whether the subactivity is complete or not
		self.number: int = number  # The number within the main activity
	
	def solve(self) -> bool:
		"""Solve the sub-activity. If it was already solved, return `False`. Otherwise, 
		return `True`."""
		
		if self.complete:
			print(f'\t\t\t\t[INFO] Part {self.number} already solved, skipping...')
			return False
		
		print(f'\t\t\t\tSolving Part {self.number}...')
		
		# self.complete = True  # This is necessary for the checksum to validate
		
		zyBook: zyBook = self.activity.section.chapter.zyBook
		session: requests.Session = zyBook.zb_session.session
		timestamp: str = datetime.datetime.utcnow().isoformat()[:-3] + 'Z'  # To follow the ISO 8601 format zyBooks uses: YYYY-MM-DDTHH:MM:SS.mmmZ (where 'T' and 'Z' are literal)
		
		url = f'https://zyserver.zybooks.com/v1/content_resource/{self.activity.id}/activity'
		
		payload = {
			'part': self.number,
			'complete': True,
			'zybook_code': zyBook.code,
			'auth_token': zyBook.zb_session.auth_token,
			'timestamp': timestamp,
			'__cs__': zyBook._generate_checksum(self.activity.id, timestamp),
		}
		
		headers = {
			'Referer': f'https://learn.zybooks.com/zybook/{zyBook.code}/chapter/{self.activity.section.chapter.number}/section/{self.activity.section.number}',
		}
		
		res = session.post(url, json=payload, headers=headers)
		
		# Check if it worked
		if (res.status_code != 200) or (not res.json()['success']):
			# raise errors.SolveFailureError(self, res)
			print(f'\t\t\t\t\t[ERROR] Error when trying to solve Part {self.number}. Skipping.')
		
		return True
